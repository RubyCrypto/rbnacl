#!/usr/bin/env ruby
module Crypto
  # The SecretBox class boxes and unboxes messages
  #
  # This class uses the given secret key to encrypt and decrypt messages.
  #
  # It is VITALLY important that the nonce is a nonce, i.e. it is a number used
  # only once for any given pair of keys.  If you fail to do this, you
  # compromise the privacy of the messages encrypted. Give your nonces a
  # different prefix, or have one side use an odd counter and one an even counter.
  # Just make sure they are different.
  #
  # The ciphertexts generated by this class include a 16-byte authenticator which
  # is checked as part of the decryption.  An invalid authenticator will cause
  # the unbox function to raise.  The authenticator is not a signature.  Once
  # you've looked in the box, you've demonstrated the ability to create
  # arbitrary valid messages, so messages you send are repudiatable.  For
  # non-repudiatable messages, sign them before or after encryption.
  class SecretBox
    # Number of bytes for a secret key
    KEYBYTES = NaCl::SECRETBOX_KEYBYTES

    # Create a new SecretBox
    #
    # Sets up the Box with a secret key fro encrypting and decrypting messages.
    #
    # @param key [String] The key to encrypt and decrypt with
    #
    # @raise [ArgumentError] on invalid keys
    #
    # @return [Crypto::SecretBox] The new Box, ready to use
    def initialize(key)
      @key = key
      raise ArgumentError, "Must provide a valid key (#{KEYBYTES} bytes)" unless valid?
    end

    # Is the key a potentially valid secret key?
    #
    # Checks length, since otherwise it's just a random string!
    #
    # @param [String] key The key to test
    #
    # @return [Boolean] Well, is it?
    def self.valid?(key)
      !key.nil? && key.to_str.bytesize == KEYBYTES
    end

    # Is the key a potentially valid secret key?
    #
    # Checks length, since otherwise it's just a random string!
    #
    # @return [Boolean] Well, is it?
    def valid?
      self.class.valid?(@key)
    end

    # Encrypts a message
    #
    # Encrypts the message with the given nonce to the key set up when
    # initializing the class.  Make sure the nonce is unique for any given
    # key, or you might as well just send plain text.
    #
    # This function takes care of the padding required by the NaCL C API.
    #
    # @param nonce [String] A 24-byte string containing the nonce.
    # @param message [String] The message to be encrypted.
    #
    # @raise [ArgumentError] If the nonce is not valid
    #
    # @return [String] The ciphertext without the nonce prepended.
    def box(nonce, message)
      raise ArgumentError, "Nonce must be #{Crypto::NaCl::NONCEBYTES} bytes long." unless nonce.bytesize == Crypto::NaCl::NONCEBYTES
      msg = Util.prepend_zeros(NaCl::ZEROBYTES, message)
      ct  = msg.dup

      NaCl.crypto_secretbox(ct, msg, msg.bytesize, nonce, @key) || raise(CryptoError, "Encryption failed")
      Util.remove_zeros(NaCl::BOXZEROBYTES, ct)
    end

    # Decrypts a ciphertext
    #
    # Decrypts the ciphertext with the given nonce using the key setup when
    # initializing the class.
    #
    # This function takes care of the padding required by the NaCL C API.
    #
    # @param nonce [String] A 24-byte string containing the nonce.
    # @param ciphertext [String] The message to be decrypted.
    #
    # @raise [ArgumentError] If the nonce is not valid
    # @raise [Crypto::CryptoError] If the ciphertext cannot be authenticated.
    #
    # @return [String] The decrypted message.
    def open(nonce, ciphertext)
      raise ArgumentError, "Nonce must be #{Crypto::NaCl::NONCEBYTES} bytes long." unless nonce.bytesize == Crypto::NaCl::NONCEBYTES
      ct = Util.prepend_zeros(NaCl::BOXZEROBYTES, ciphertext)
      message  = ct.dup

      NaCl.crypto_secretbox_open(message, ct, ct.bytesize, nonce, @key) || raise(CryptoError, "Decryption failed. Ciphertext failed verification.")
      Util.remove_zeros(NaCl::ZEROBYTES, message)
    end
  end
end
