#!/usr/bin/env ruby
module Crypto
  # The Box class boxes and unboxes messages
  #
  # This class uses the given public and secret keys to derive a shared key,
  # which is used with the nonce given to encrypt the given messages and
  # decrypt the given ciphertexts.  The same shared key will generated from both
  # pairs of keys, so (pk1, sk2) == (pk2, sk1).  This is how the system works.
  #
  # It is VITALLY important that the nonce is a nonce, i.e. it is a number used
  # only once for any given pair of keys.  If you fail to do this, you
  # compromise the privacy of the the messages encrypted.  Also, bear in mind
  # the property mentioned just above. Give your nonces a different prefix, or
  # have one side use an odd counter and one an even counter.  Just make sure
  # they are different.
  #
  # The ciphertexts generated by this class include a 16-byte authenticator which
  # is checked as part of the decryption.  An invalid authenticator will cause
  # the unbox function to raise.  The authenticator is not a signature.  Once
  # you've looked in the box, you've demonstrated the ability to create
  # arbitrary valid messages, so messages you send are repudiatable.  For
  # non-repudiatable messages, sign them before or after encryption.
  class Box

    # Create a new Box
    #
    # Sets up the Box for deriving the shared key and encrypting and
    # decrypting messages.
    #
    # @param public_key [String,Crypto::PublicKey] The public key to encrypt to
    # @param private_key [String,Crypto::PrivateKey] The private key to encrypt with
    #
    # @raise [ArgumentError] on invalid keys
    #
    # @return [Crypto::Box] The new Box, ready to use
    def initialize(public_key, private_key)
      @public_key  = public_key.respond_to?(:to_bytes)  ? public_key.to_bytes  : public_key
      @private_key = private_key.respond_to?(:to_bytes) ? private_key.to_bytes : private_key
      raise ArgumentError, "Must provide a valid public key" unless PublicKey.valid?(@public_key)
      raise ArgumentError, "Must provide a valid private key" unless PrivateKey.valid?(@private_key)
    end

    # Encrypts a message
    #
    # Encrypts the message with the given nonce to the keypair set up when
    # initializing the class.  Make sure the nonce is unique for any given
    # keypair, or you might as well just send plain text.
    #
    # This function takes care of the padding required by the NaCL C API.
    #
    # @param nonce [String] A 24-byte string containing the nonce.
    # @param message [String] The message to be encrypted.
    #
    # @raise [ArgumentError] If the nonce is not valid
    #
    # @return [String] The ciphertext without the nonce prepended.
    def box(nonce, message)
      raise ArgumentError, "Nonce must be #{Crypto::NaCl::NONCEBYTES} bytes long." unless nonce.bytesize == Crypto::NaCl::NONCEBYTES
      msg = Util.prepend_zeros(NaCl::ZEROBYTES, message)
      ct  = msg.dup

      NaCl.crypto_box_afternm(ct, msg, msg.bytesize, nonce, beforenm) || raise(CryptoError, "Encryption failed")
      Util.remove_zeros(NaCl::BOXZEROBYTES, ct)
    end

    # Decrypts a ciphertext
    #
    # Decrypts the ciphertext with the given nonce using the keypair setup when
    # initializing the class.
    #
    # This function takes care of the padding required by the NaCL C API.
    #
    # @param nonce [String] A 24-byte string containing the nonce.
    # @param ciphertext [String] The message to be decrypted.
    #
    # @raise [ArgumentError] If the nonce is not valid
    # @raise [Crypto::CryptoError] If the ciphertext cannot be authenticated.
    #
    # @return [String] The decrypted message.
    def open(nonce, ciphertext)
      raise ArgumentError, "Nonce must be #{Crypto::NaCl::NONCEBYTES} bytes long." unless nonce.bytesize == Crypto::NaCl::NONCEBYTES
      ct = Util.prepend_zeros(NaCl::BOXZEROBYTES, ciphertext)
      message  = ct.dup

      NaCl.crypto_box_open_afternm(message, ct, ct.bytesize, nonce, beforenm) || raise(CryptoError, "Decryption failed. Ciphertext failed verification.")
      Util.remove_zeros(NaCl::ZEROBYTES, message)
    end

    private
    def beforenm
      @k ||= begin
               k = Util.zeros(NaCl::BEFORENMBYTES)
               NaCl.crypto_box_beforenm(k, @public_key, @private_key) || raise(CryptoError, "Failed to derive shared key")
               k
             end
    end
  end
end
